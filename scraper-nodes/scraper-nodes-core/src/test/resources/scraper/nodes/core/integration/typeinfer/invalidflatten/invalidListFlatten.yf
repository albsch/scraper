name: flatten
graphs:
  start:
    - type: EchoNode
      puts:
        toFlatA: ["a","b"]              # toFlatA :: List<String>
        toFlatB: [{a: ["1","2"]},"d"]   # toFlatB :: List<Object>

    - type: FlattenListNode
      flatten: ["{toFlatA}", "{toFlatB}"] # output :: List<?>
                                          #     Option 1: Generalize known type to List<Object> (in FlattenListNode <K> would be Object)
                                          #             Problem: Templates start to behave weirdly, see EchoNode below
                                          #
                                          #     Option 2: Prohibit this, all element types of the list should be the same
                                          #                 => makes FlattenListNode less useful, worse option
                                          #
                                          #     Option 3: Introduce new Object Type Mixed, which tracks which index/key is assigned to what object if it is a list/map
                                          #                 => more complex, not sure if this would work


    - type: EchoNode
      log:
        toFlatten: "{{{output}}[2]@a}"            # {output} needs to be List<Map<String, ?>>
                                                  # because of the array access [2] and the map lookup @a
                                                  # this is also the expected type @output, but it's actually List<Object>, as generalized with Option 1
                                                  # with option 2 this would still work, but then the flattening itself would fail

    - type: FlattenListNode
      flatten: ["{{{output}}[2]@a}"]


#  Könntest du dir das anschauen und mir Feedback geben? Ich glaube ich renne seit ein paar Tagen gegen Javas Typsystem und will das so hinbiegen, dass es irgendwie sinnvoll mit Templates funktioniert. Tut es aber nicht wirklich.
#
#Hier in diesem Beispiel sieht man das deutlich:
#  Entweder ich lasse zu, das die FlattenListNode den generischen Typ K so generisch wählt, dass er passt (i.e. Object). Dann geht aber das Template System später kaputt, weil es eine konkrete Klasse erwartet, statt Object. Wenn ich diese downcasts für Templates zulasse, dann habe ich aber das Problem, dass List<Integer> auswertet, obwohl die Liste ["not an int"] ist.
